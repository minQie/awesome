1、序列化只能序列化堆内存里面的内容，static修饰的变量不会被序列化，transient修饰的也不会序列化

2、serialVersionUID对应这类的结构而不是给特定new的一个对象起个名字（早期误区，其实很离谱）
	可以通过自定义UID使读取的对象和当前的class文件定义的类的结构不同，当然最多是权限修饰符不同，
	你实在什么存的时候没有，之后又多加的一个，加载存储被实例化对象的文件成对象的时候，比较现在那个对象
	属于的类的话，就会有少胳膊，少腿的感觉。或者多一个，没错是没错，相较于更改之后的类结构，就多存了用
	不上的垃圾信息。还有例如，实例化对象之前有transient修饰的变量，存到文件里，再读
	的时候，由于没存，读取生成的对象的被transient修饰的那个变量依旧是创建新对象的时候初始值。
	（意思是不会报错，你使用默认生成的UID，将对象存到一个文件里，然后改变那个对象的java文件，
	重新编译生成新的class文件，然后你根据当前的class文件来加载文件里的对象，会直接报错，报错原因
	：你文件里存的对象的数据对应不上重新生成的框架了。就是结构不对，虚拟机怎么判断就是根据这个由class
	文件对应的java里你写的变量啊、方法啊算出来的serialVersionUID相不相同，当然只要结构不相同，产生的
	serialVersionUID肯定不相同）

3、如果你要序列化的对象含有其他对象的引用，序列化因为记录的是数据，当然也会把含有的引用对应的对象序列化，
所以那个对象也需要实现Serializable接口，其实还有一些文件信息，比如做图形化界面的时候引用的图片，那里就有点
复杂，将一个图片的信息存到文件里。

PS：存储实例化的对象的文件，后缀名用object

个人猜想：以后的框架是为了规范写代码的步骤，那么框架肯定是这样，要改变某些对象的成员变量的值，肯定要通过
这个类提供的方法，如果有需要根据多个类操作的步骤，那这个肯定是放在一个专门操作的方法类中，这样我们实例化的时候，
就对每个要操作的对象实例化，而不会实例化这个含各个对象引用的这个提供方法的类生成的对象。
比如下100层的RunJPanel就不应该实现多线程方法，搞得一个面板在进行主操作