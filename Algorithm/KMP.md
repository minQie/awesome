# KMP

## 声明

​	一般我们会通过产生的动机，如何去解决问题去正向的切入了解算法。但是KMP并不适合，除了自己通过研读数据结构数据的收获，结合知乎的文章：https://www.zhihu.com/question/21923021，系统整理出KMP的核心，应该如何去理解KMP

## 什么是KMP？

​	在一段给定的文本内容中（下文中的主串），查找指定的内容（下文中的模式串），简单点说就是文本搜索。 直觉做法就是按字符逐位比较，如果文本中存在某段连续字符序列和要查找的字符序列相同，则认为串找到、搜索到。KMP就是这个低效直觉做法的优化改进版，传统做法的时间复杂度是O(m*n)，而KMP的时间复杂度是O(m + n)

​	假设从某个字符位开始进行模式串匹配进行到某个字符位失败了，这时从比较起始位匹配失败的字符位之前的匹配过程并不是无意义的，利用好就可以提前判断并跳过一些一定会失败的匹配初始位置，从而大大提高串匹配的效率，如何利用就是通过构建PMT，通过PMT进行串匹配就是KMP

## PMT

​	Partial Match Table，作为KMP的核心体现，PMT是一个整型数组，其大小同模式串；当匹配失败时，就获取模式串中导致匹配失败的字符对应整型数组位置的整数n，接下来，模式串的第next[n]个字符与主串匹配失败的字符对齐，接着进行匹配

### 核心算法

```c
#include<stdio.h>
#include<stdlib.h>

void getNext(char T[], int next[]);
void main() {
	char T[9] = {8,'a','b','a','a','b','c','a','c'};
	int next[9];
	getNext(T, next);
	//for (int i = 1; i<=8; i++) {
	//	printf("%d ",next[i]);
	//}
}

void getNext(char T[], int next[]) {
	next[1] = 0;

	int i = 1;
	int j = 0;
	while (i <= T[0]) {
		if (j == 0 || T[i] == T[j]) {
			++i;
			++j;
			next[i] = j;
		} else {
			j = next[j];
		}
	}
	
}
```

### 构建过程

​	NEXT数组的数据就是由真正的PMT数组所有元素都向右平移一位得到的（这就是贴出的核心算法会出现数组越界的原因，都是为了核心代码简明，便于理解），下文的说法都是以贴出的求next数组的算法为主，思想是一样的

1. 模式串字符数组下标为0的空间存储了模式串的长度，NEXT数组整型数组同理，也从下标为1的位置开始存储数据

2. 因为NEXT是动态规划的结果，故求NEXT实际就是使用KMP进行串匹配的过程，这里拿模式串自身作为主串

- **初始化**

  ```
  j i
  ↓ ↓
    a b a a b c a c
  ```

  ```
    0 - - - - - -
  ```

- **循环（当i超出主串大小，则循环结束）**

  **第一轮**（j == 0）

  ---

  i j 自增，next[i] = j → next[2] = 1

  ```
    j i
    ↓ ↓
    a b a a b c a c
  ```

  ```
    0 1 - - - - - -
  ```

  pmt[2] = 1：当模式串与主串的第2位不匹配时，应该将模式串的第1位与不匹配的字符位对齐；实际就是将模式串向右移了一位，也就是和普通的串匹配没有区别，因为模式串的开头两个字符并不相同（你细品）

  **第二轮**（T[2] != T[1]）

  ---

  j 赋值为 next[j] → next[1] → 0

  ```
  j   i
  ↓   ↓
    a b a a b c a c
  ```

  ```
    0 1 - - - - - -
  ```

  **第三轮**（j == 0）

  ---

  i j 自增，next[i] = j → next[3] = 1

  ```
    j i
    ↓ ↓
    a b a a b c a c
  ```

  ```
    0 1 1 - - - - -
  ```

  next[3] = 1：当模式串第3位与主串的不匹配时，应该将模式串的第1位与不匹配的字符位对齐；实际将模式串向右移了两位，PMT初显威力，没有问题因为右移一位进行比较（a != b）

  **第n轮**

  ---

  ```
    0 1 1 2 2 3 1 2
  ```

### 示例

​	在主字符串**ab ab ab ab ca**中查找模式字符串**ab ab ab ca**（i 指针指向主串的第7个字符，j的值是7）

主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i-1 这一段是与模式字符串的 0 到 j-1 这一段是完全相同的

`主字符串在 7 位失配，也就意味着主字符串从 0 到 6 这一段是与模式字符串的 0 到 6 这一段是完全相同的`

主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的

`主字符串中 i 指针之前的 4 位就一定与模式字符串的第 0 位至第 4 位是相同的`

在这个案例中，就是**ab ab ab**，其前缀集合与后缀集合的交集的最长元素为**ab ab**，长度为4，故PMT[6] = 4。所以就可以断言，主串中 i 指针之前的 4 位一定与模式字符串的第 0 位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持 i 指针不动，然后将j指针指向模式字符串的PMT[j −1] + 1位即可

## 总结

1. **PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**

2. **PMT由模式串本身决定，和主串没有任何关系**

3. **这样的匹配过程，与传统串匹配相比，主串的匹配指针不会发生回溯，串匹配不用每一次都从模式串的第1字符开始匹配。加上算法具体实现也不复杂，所以KMP是很优秀的算法，但要明确KMP仅仅是在主串和子串有很多“部分匹配”的情况下，跳过的无意义匹配次数才明显，否则KMP和普通的串匹配的效率相差不大。尽管朴素的模式匹配的时间复杂度是O(m*n)，但在一般情况下，朴素的模式匹配算法的实际执行时间近似O(m+n)，因此至今任然被采用**

## 书本

实际书本上也直接阐明上述求next数组的算法不好理解，故介绍了一种手工求解next数组的方法：（P270）
（1）next[1]=0，next[2]=1。（next[0]不用）
（2）后面求解每一位的next[j]值时，根据j的前一位进行比较，令k=next[j-1];
（3）将S[j-1]与S[k]进行比较：
	a.如果相等，则该next[j]=k+1;
	b.如果不等，令k=next[k]，若k不等于0，跳到(3)；若k等于0，next[j]=1。
上面的这种“机械”的做法在考试中不推荐，所以还介绍了一种教你在做题中求next数组的方法

