# 数组和指针

## 何为数组名

数组名的值等于数组首元素的地址,可以通过数组名加上角标的形式来获取数组中的元素,数组名的多重取地址都与数组名的值相等,调用printf("%d %d",数组名,&数组名);语句可以在控制台得到两个一样的值,怎么理解：&数组名 -> 数组的地址 ->数组首元素的地址

 

硬要说数组名的类型的话,例：int array[i];的array是int []类型,int array[i][j];中的array则是  int [][]类型

## 基本数据类型的指针和一维数组

### 语法分析

```c++
#include<stdio.h>
#include<stdlib.h>

void method1 (int *p)
{
	p[2]=2;
}

void method2 (int array[])
{
	array[2]=2;
}

void main()
{
	int array[5];
	int *p=(int *)malloc(5*sizeof(int));// 不申请空间执行method肯定报错
    
	method1 (p); // 1
	method2 (p); // 2
	method1 (array); // 3
	method2 (array); // 4
    
    p=array; // 5
    array=p; // 6
}
```

整个程序就只有6会报错：cannot convert from 'int *' to 'int [5]'

### 参数方面

从上例可以看到形参为int *可以接收int *和int [],形参为int[]也可以接收int *和int []

### 返回值方面

函数申明方面：int[] function()、char[] function()等,都是不能通过编译的,想要返回数组的话只能指针来代替,例如：int * function、char * function()

 

***\*注意：返回的数组的确存有刚刚函数中操作的数据，但是如果那个数组是在函数中申请的空间，那么即使你用指针记录返回的数组，其实那块空间依旧被VC视为可被其他变量申请的空白无人用的空间，所以其他的操作可能改变该空间内存储的数据，所以在返回数组后任然要多次操作返回的数组，那我们最好申请空间记录下返回的数组中的数据或者将一个已经申请好的空间作为参数传递，有具体错例\****

### 赋值方面

你发现int []可以赋值给int *,但是int *却不能赋值给int [],即使用另一个数组名来赋值也不行，其实你最终将得到***\*数组名不能进行赋值操作\****的结论,这和java不同点在于,java定义了一个数组,java不会给该数组申请空间,手动new或者引用别的数组都行,java万物皆对象,但是C语言里,只要定义了一个数组就肯定会先申请空间,空间的大小就由中括号的值来决定

 

***\*再而指针能像数组名一样通过角标来获取数组元素,数组名也可以像指针那样用\*变量名获取对应地址的值\****

### 引出疑问

疑问：那int **a和 int b[][]中的a和b为什么不行像上述那样?

产生原因：运用int **动态申请二维数组后, int **指针可以像数组名一样通过行标和列标获取到数组中的元素,当然还可以通过指针的特性用&符来获取地址对应的元素

解答

1、 从语法上：你强行将b赋值给a,编译时会报错并告诉你无法将int [][]类型转化为int **类型

2、 在功能上：数组名的值是不能变的,一旦定义其值就等于一个常量,这个java的final关键字有点像,因此数组名是不可能作为指针来用的

### 实例拓展

```c
void method3(int *&p)
{
	p[2]=2;
}

void main()
{
	int array[5];
	int *p=(int *)malloc(5*sizeof(int));
	method3 (p); // 1
	method3 (array); // 2
}
```

2报错：cannot convert parameter 1 from 'int [5]' to 'int *& '

## 指向一维数组的指针

***\*语法：\****数据类型 (*变量名)[要指向的数组的长度];

### 与一维数组的关系

int (*p)[i];// p就是一个指向int型,长度为i的一维数组的指针

int array[i];

p = &array;

### 与二维数组的关系

int (*p)[j];

int array[i][j];

***\*正确的赋值1：\****p=&array[0];

***\*如此理解：\****array[0]相当于二维数组array中的下标为0的第一个一维数组的数组名

***\*错误：\****如果根据 &数组名=数组名=数组首元素的地址 等同于&array[0]=array[0]=&array[0][0]从而p=&array [0][0],这样赋值那就错了

***\*原因：\****根据指向数组指针的赋值格式,&后接的是一个数组名,我们就该把后面接的字段理解为数组名,朝别的方向理解,你都会得到很多令人诧异的结果,例如：你认定不存在&array[0], array[0]就仅仅是一个地址值（&array[0][0]）你如何取地址呢,这好比&1,毫无意义可言.但是通过printf("%d %d %d",array[0],&array[0],&array[0][0]);语句你还是获得三个相同的值,但要知道他们的类型是完全不同的,并且类型也要分语境,这里就不强行列出

 

***\*正确的赋值2：\**** p=array;

***\*如此理解：\**** array -> &array[0] 

### 指向数组后获取数组元素

```c
int i,(*p)[3];
int ch[]={1,2,3};

p=&ch;

for(i=0;i<3;i++)
{
    printf("%d ",p[i]);//1638188 1638200 1638212 

    printf("%d ",*p[i]);//1 1638188 4198921 

    printf("%d ",(*p)[i]);//1 2 3 
}
```

## 指向一维数组的指针组

***\*语法：\****数据类型(*变量名[i])[j];,i代表指针组指针的个数,j代表每个指针要指向的数组的长度

### 与一维数组的关系

```c
int a[6],b[6],c[6];

int (*p[3])[6];

p[0]=&a;

p[1]=&b;

p[2]=&c;
```

### 与二维数组的关系

```c
int array[3];

int (*p[3])[6];

for(int i = 0;i<3;i++) {
	p[i] = array[i];
}
```

## 指向二维数组的指针

***\*语法：\****数据类型 (*变量名[i])[j];

### 与一维数组的关系

没有关系

### 与二维数组的关系

int (*p)[i][j];

int array[i][j];

p=&array;

### 与指向一维数组指针的指针的关系

申请存储100个长度都为10的一维数组名的空间

动态申请:

​	int (**p)[10];

​	p=(int (**)[10])malloc(n*sizeof(int *));//这样写不会报错,但是大小可能不对应

静态申请:

​	int *p[100][10];

只要对应最初始的int *,可以用来动态申请一维int数组来理解就好,要是根据int (*p)[i]和int array[],之间的赋值：p=&array来推int(**p)[i]的话赋值是不是p=array,那就大错特错了

## 指针的移动

### 开篇引用

```c
#include<stdio.h>
#include<stdlib.h>

typedef struct
{
	int data1;

	int data2;
} a, *A;

typedef struct
{
	A base;

	A top;
} b, *B;

 

void main()
{
	b stack;
	stack.base=(A)malloc(100*sizeof(a));
}
```

指针加加,加的是该指针指向的数据类型(结构)的大小,对上例中的stack.base++加的值是sizeof(a)的大小,因为stack.base是指向a结构体的指针,因此数组也是同理的

### 通过数组名找地址

例1：int a[5] = {1,2,3,4}; 

&a 类型为指向一维数组(4个元素)的指针,即 int (*)[4]

&a+1的值为：a的地址 + 4*sizeof(int)

a+1的值为：a的地址 + 1*sizeof(int)

 

例2：int b[3][4] = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12}}; 

&b 类型为int (*)[3][4]

&b+1值为：b的地址 + 3*4*sizeof(int)

b+1值为：b的地址 + 4*sizeof(int)

注意：没有&(b+1),这里真的是对一个整数取地址了,***\*+的优先级大于&\****

### 通过数组名地址取值

```c
void main()
{

	int i,n,m;
	char (**p)[3],str[10][3]={"零","壹","贰","叁","肆","伍","陆","柒","捌","玖"};
 

	printf("输入几个数字:");
	scanf("%d",&n);


	p=(char (**)[3])malloc(n*sizeof(char *));

	printf("输入相应的数据:");

	for(i=0;i<n;i++)
	{
		scanf("%d",&m);

		p[i]=str+m;
	}

	for(i=0;i<n;i++) printf("%s ",p[i]);

	putchar(10);
}

// 从上面一维二维数组名获取的地址可以发现，通过数组名的地址取值顶多是一维，除非强行根据地址值来例如：

int array[4][4]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};

printf("%d\n",*((int*)((int)array+(int)(15*4))));

// 这样可以强行打印出array[3][3]的值16
```

## 总结

光是结构体之间的互相指引，在一定程度上已经有点复杂了，例如还可以再有指向结构体组的指针(组)等等，所以指针是可以很复杂的，这里不可能一直列举，只是提供思维方式！